{"version":3,"file":"static/webpack/1.dd3ab368354c0081a917.hot-update.js","sources":["webpack:///./components/visualization/threat/createThreatVisual.js"],"sourcesContent":["import * as d3 from 'd3';\nimport chroma from 'chroma-js';\nimport translations from './translationsThreat';\nimport { interpolatePlasma, interpolateCool, interpolateTurbo, interpolateViridis} from 'd3-scale-chromatic'\n\nimport {\n    makeConcepts,\n    makeThreats\n} from './data';\n\nconst FILL_COLOR = 'black';\nconst BACK_COLOR = 'white';\n\nfunction createThreatVisual() {\n  let hover_ich = null;\n  let threats;\n  //Constants\n  const pi = Math.PI;\n  const pi2 = Math.PI * 2;\n  const pi1_2 = Math.PI / 2;\n\n  //Sizes\n  let base_size = 1600;\n  let width = 1600,\n    height = 1600;\n  let total_width, total_height;\n  let margin = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n  };\n\n  //Containers SVG\n  let svg, g;\n  let g_scale;\n\n  //Containers canvas\n  let canvas_edges, canvas_nodes, canvas_hover;\n  let ctx_edges, ctx_nodes, ctx_hover;\n  let sf = 2; //canvas scale factor\n  let sf_original = sf;\n  let sf_set = false;\n  let sf_set_original = sf_set;\n\n  //Data\n  let nodes;\n  let elements;\n  let concepts;\n  let language;\n  let edges;\n  let edges_concepts = [],\n    edges_elements = [];\n\n  //Mappings\n  let node_by_id = {};\n  let linked_to_id = {};\n  let threat_by_id = {};\n  let concept_by_id = {};\n  let edge_concept_by_id = {};\n  // let edge_element_by_id = {}\n  // const threat_metadata_colorscale = d3.scaleSequential().range(interpolateTurbo)\n\n  //Threats metadata\n  const threat_metadata = [\n    { id: 'vocabulary_ich_1265', color: '#fca636' }, //Adverse circumstances\n    { id: 'vocabulary_ich_1268', color: '#f2844b' }, //Demographic issues\n    { id: 'vocabulary_ich_1287', color: '#E01A25' }, //Derived practice\n    { id: 'vocabulary_ich_1264', color: '#C20049' }, //Environmental degradation\n    { id: 'vocabulary_ich_1286', color: '#991C71' }, //Weakened practice and transmission\n    { id: 'vocabulary_ich_1263', color: '#66489F' }, //Globalized information\n    { id: 'vocabulary_ich_1284', color: 'rgb(54, 140, 225)' }, //New products and techniques\n    { id: 'vocabulary_ich_1269', color: 'rgb(35, 171, 216)' }, //Missing objects, spaces or systems\n    { id: 'vocabulary_ich_1267', color: '#7EB852' }, //Socioeconomical problems\n  ];\n\n  threat_metadata.forEach((d, i) => {\n    console.log(interpolatePlasma(i * 0.1))\n    d.color = interpolatePlasma(i * 0.1);\n  });\n  const threat_ids = threat_metadata.map(d => d.id);\n  const color_threat_scale = d3\n    .scaleOrdinal()\n    .domain(threat_ids)\n    .range(threat_metadata.map(d => d.color));\n\n  //Scale for the radius of the concepts, based on their degree\n  const scale_concept_radius = d3\n    .scaleSqrt()\n    .domain([0, 30])\n    .range([0, 70]);\n  //Scale for the radius of the threats, based on their degree\n  const scale_threat_radius = d3\n    .scaleSqrt()\n    .domain([0, 30])\n    .range([0, 80]);\n\n  //ICH elements\n  let node_radius = 20;\n  const radius_elements = 600;\n  const radius_elements_offset = 1.1 * node_radius;\n  const radius_elements_title = 680;\n  const arc_nodes = d3.arc();\n  const pie_nodes = d3\n    .pie()\n    .sort(null)\n    .value(1);\n\n  //Threat categories\n  const radius_threats = 580;\n  // const threat_circle_radius = 6\n  const threat_line_height = 30;\n\n  //Threat concepts\n  const concept_radius = 6;\n  const radius_concept = 600;\n  const radius_concept_title = 450;\n  // const radius_dot_concept = radius_concept\n  let concept_arcs;\n  const arc_concept = d3.arc();\n  const pie_concept = d3\n    .pie()\n    .value(d => d.values.length)\n    .sort(null);\n  let threats_nest;\n\n  //Visual styles\n  const opacity_concept_default = 0.5;\n  const opacity_element_default = 0.1;\n  let arc_gradient_nodes;\n  let arc_gradient_hover;\n\n  //Mouse hovers\n  const voronoi = d3\n    .voronoi()\n    .x(d => d.x)\n    .y(d => d.y);\n  let diagram;\n  let mouse_hover_active = false;\n  let current_hover = null;\n  let hover_type = null;\n  let timer_draw = null;\n\n  //Mouse clicks\n  let current_click = null;\n  let click_active = false;\n  let hover_concept, hover_category;\n\n  //Other\n  let font_family = 'Oswald';\n  let scale_factor = 1;\n  let scale_multiplier = 1;\n  let threat_definitions;\n  let ICH_num, ICH_num_all;\n  let showModal = function(element) {\n    console.log(element);\n  };\n\n  //////////////////////// Element edges ///////////////////////\n  //Line drawing function for the element edges\n  const line = d3\n    .line()\n    .x(d => d[0])\n    .y(d => d[1])\n    // .curve(d3.curveBundle.beta(1))\n    .curve(d3.curveBasis);\n\n  //All are based on the distance between the category and ICH element\n  //The radius of the first anchor point\n  const cr1_offset_scale = d3\n    .scaleLinear()\n    .domain([0, 2 * radius_threats])\n    .range([-20, -150])\n    .clamp(true);\n  //The radius of the second anchor point\n  const cr2_offset_scale = d3\n    .scaleLinear()\n    .domain([0, radius_threats])\n    .range([0, 175])\n    .clamp(true);\n  //The angle of the second anchor point\n  const angle2_offset_scale = d3\n    .scaleLinear()\n    .domain([0, radius_threats])\n    .range([1, 0.5])\n    .clamp(true);\n\n  function chart(selection, nodes_raw, edges_raw, lang = 'en', callback) {\n    language = lang;\n    nodes = nodes_raw;\n    edges = edges_raw;\n\n    threat_definitions = translations[language].definitions;\n\n    //////////////////////////////////////////////////////////////\n    //////////////// Create the canvas containers ////////////////\n    //////////////////////////////////////////////////////////////\n\n    //Canvas for the edges\n    canvas_edges = selection.append('canvas').attr('id', 'canvas-edges');\n    ctx_edges = canvas_edges.node().getContext('2d');\n\n    //Canvas for the nodes\n    canvas_nodes = selection.append('canvas').attr('id', 'canvas-nodes');\n    ctx_nodes = canvas_nodes.node().getContext('2d');\n\n    //Canvas for the hover effects - mostly for performance\n    canvas_hover = selection.append('canvas').attr('id', 'canvas-hover');\n    ctx_hover = canvas_hover.node().getContext('2d');\n\n    //////////////////////////////////////////////////////////////\n    ////////////////// Create the SVG container //////////////////\n    //////////////////////////////////////////////////////////////\n\n    //SVG container for the things on top such as text\n    svg = selection\n      .append('svg')\n      .on('mousemove', findElement)\n      .on('click', d => {\n        click_active = false;\n        mouseOverReset();\n      });\n\n    //Group for all _visual elements\n    g = svg.append('g').attr('id', '_visual-elements-group');\n\n    g_scale = g.append('g').attr('id', 'scaling-group');\n\n    //////////////////////////////////////////////////////////////\n    ////////////////////// Data preparation //////////////////////\n    //////////////////////////////////////////////////////////////\n\n    //General, data only, preparation to create the correct arrays\n    dataPreparation();\n\n    //Calculate node locations\n    nodePlacement();\n    //Calculate edge locations\n    edgePlacement();\n\n    chart.resize();\n\n    //////////////////////////////////////////////////////////////\n    ////////////////////// Set-up the voronoi ////////////////////\n    //////////////////////////////////////////////////////////////\n\n    //Calculate a voronoi layout - for mouse events\n    diagram = voronoi(elements);\n\n    // //Show the voronoi sites\n    // g_scale.append(\"g\")\n    //     .attr(\"class\", \"element-group\")\n    //     .selectAll(\".element-cell\")\n    //     .data(diagram.polygons())\n    //     .enter().append(\"path\")\n    //     .attr(\"class\", \".element-cell\")\n    //     .style(\"fill\", \"none\")\n    //     .style(\"stroke\", \"black\")\n    //     .style(\"pointer-events\", \"none\")\n    //     .attr(\"d\", d => d ? \"M\" + d.join(\"L\") + \"Z\" : null)\n\n    //////////////////////////////////////////////////////////////\n    //////////////////////////// Draw ////////////////////////////\n    //////////////////////////////////////////////////////////////\n\n    //Create a gradient for the lower arc with ICH labels\n    function createGradient(ctx) {\n      let num = threat_metadata.length - 1;\n      let grd = ctx.createLinearGradient(\n        -radius_elements_title,\n        0,\n        radius_elements_title,\n        0\n      );\n      for (let i = 0; i <= num; i++)\n        grd.addColorStop(i / num, threat_metadata[i].color);\n      return grd;\n    } //function createGradient\n    arc_gradient_nodes = createGradient(ctx_nodes);\n    arc_gradient_hover = createGradient(ctx_hover);\n\n    //Set-up the final parts of the arc functions\n    prepareArcs();\n\n    //Calculate the edge curves\n    calculateEdgeCenters(edges_concepts);\n\n    //Setup the hidden SVG mouseover elements\n    drawHiddenElements();\n    setHiddenHovers();\n\n    //Draw all the pieces on the canvases\n    drawCanvas();\n\n    //Return filtered nodes\n    if (callback) callback(elements);\n  } //function chart\n\n  //////////////////////////////////////////////////////////////\n  ///////////////////// Resize the chart ///////////////////////\n  //////////////////////////////////////////////////////////////\n\n  chart.resize = () => {\n    total_width = width + margin.left + margin.right;\n    total_height = height + margin.top + margin.bottom;\n\n    //Change sizes of the svg\n    svg.attr('width', total_width).attr('height', total_height);\n    g.attr(\n      'transform',\n      'translate(' +\n        (margin.left + width / 2) +\n        ',' +\n        (margin.top + height / 2) +\n        ')'\n    );\n\n    //Get the scale factor to resize\n    let size = Math.min(total_height, total_width);\n    scale_factor = roundTo((size / base_size) * scale_multiplier, 2);\n    //Scale everything to fit\n    g_scale.attr('transform', 'scale(' + scale_factor + ')');\n\n    //Update voronoi for mouseover\n    voronoi.extent([\n      [\n        (-margin.left - width / 2) / scale_factor,\n        (-margin.top - height / 2) / scale_factor,\n      ],\n      [total_width, total_height],\n    ]);\n\n    //If the canvas scale factor hasn't been set yet, figure out the best for this screen\n    if (!sf_set) {\n      sf = Math.min(2, getPixelRatio(ctx_nodes)); //no more than 2\n      sf_original = sf;\n    } //if\n\n    //Change sizes of the canvas based on the scale factor\n    crispyCanvas(canvas_edges, ctx_edges);\n    crispyCanvas(canvas_nodes, ctx_nodes);\n    crispyCanvas(canvas_hover, ctx_hover);\n\n    //Redraw\n    drawCanvas();\n\n    return 1; //Needed for the saveImage function\n  }; //function resize\n\n  //////////////////////////////////////////////////////////////\n  ///////////////// General data preparation ///////////////////\n  //////////////////////////////////////////////////////////////\n\n  /////////////////// Initial data filtering ///////////////////\n  function dataPreparation() {\n    ///////////////////// COUNTRY MAPPING ////////////////////\n\n    //Create a node -> node id mapping\n    node_by_id = {};\n    nodes.forEach(d => {\n      node_by_id[d.id] = d;\n    });\n\n    //What connections remain per node\n    linked_to_id = {};\n    edges.forEach(d => {\n      //Save all of the connections to a specific node\n      if (!linked_to_id[d.source]) linked_to_id[d.source] = [];\n      if (!linked_to_id[d.target]) linked_to_id[d.target] = [];\n      linked_to_id[d.source].push(node_by_id[d.target]);\n      linked_to_id[d.target].push(node_by_id[d.source]);\n    }); //forEach\n\n    //Attach a list of countries to the ICH elements\n    nodes\n      .filter(d => d.type === 'element')\n      .forEach(d => {\n        d.countries = linked_to_id[d.id]\n          .filter(l => l.type === 'country')\n          .map(l => l.label);\n      });\n\n    //////////////////// INITIAL FILTERING ///////////////////\n\n    nodes = nodes.filter(d => {\n      //Filter out any elements that are not on the urgent list\n      if (d.type === 'element') return d.meta.list === 'USL' ? true : false;\n      //Filter out any node that is a concept that isn't of group: threat\n      else if (d.type === 'concept') return d.group === 'threat' ? true : false;\n      else return false;\n    }); //filter\n\n    //Create a node -> node id mapping: 52 ICH elements, 9 categories & 54 threats\n    node_by_id = {};\n    nodes.forEach(d => {\n      node_by_id[d.id] = d;\n    });\n    //Filter out any edges that were associated to the nodes filtered above\n    edges = edges.filter(d => {\n      return node_by_id[d.source] && node_by_id[d.target];\n    });\n\n    //Second filtering based on connections\n    nodes = nodes.filter(d => {\n      d.degree = edges.filter(l => l.source == d.id || l.target == d.id).length;\n      //Filter out any element that has 0 degrees\n      if (d.type === 'element') return d.degree >= 1 ? true : false;\n      //Keep all threat categories\n      else if (threat_ids.indexOf(d.id) >= 0) return true;\n      else {\n        //Only keep threats that have a connection to a remaining ICH element\n        let connections = edges.filter(\n          l =>\n            (l.source === d.id && node_by_id[l.target].type === 'element') ||\n            (l.target === d.id && node_by_id[l.source].type === 'element')\n        );\n        return connections.length >= 1 ? true : false;\n      } //else\n    }); //forEach\n\n    //Create a node -> node id mapping\n    node_by_id = {};\n    nodes.forEach(d => {\n      node_by_id[d.id] = d;\n    });\n\n    //What connections remain per node\n    linked_to_id = {};\n    edges.forEach(d => {\n      //Save all of the connections to a specific node\n      if (!linked_to_id[d.source]) linked_to_id[d.source] = [];\n      if (!linked_to_id[d.target]) linked_to_id[d.target] = [];\n      linked_to_id[d.source].push(node_by_id[d.target]);\n      linked_to_id[d.target].push(node_by_id[d.source]);\n    }); //forEach\n\n    //////////////////// THREAT CATEGORIES ///////////////////\n\n    //Connect the translations to the threat_metadata\n    let data_translations = translations[language].categories;\n    threat_metadata.forEach(\n      d =>\n        (d.label =\n          data_translations[\n            data_translations.map(b => b.id).indexOf(d.id)\n          ].label)\n    );\n\n    //Find the threat categories - ones that are not connected to a ICH element\n    threats = nodes.filter(d => {\n      //Is this id in the predefined list\n      return threat_ids.indexOf(d.id) >= 0;\n    }); //filter\n\n    makeThreats(threats);\n\n    threats.forEach(d => {\n      d.meta = threat_metadata[threat_ids.indexOf(d.id)];\n      d.meta.label = d.label;\n      d.title = d.meta.label;\n      d.group = 'threat category';\n      d.degree = 0;\n      threat_by_id[d.id] = d;\n    }); //forEach\n    //Sort them by the id defined above\n    threats = threats.sort(\n      (a, b) => threat_ids.indexOf(a.id) - threat_ids.indexOf(b.id)\n    );\n\n    // console.log(threats.map(d => d.label))\n    // //Between 3 - 9 & 15 for weakened practice\n\n    ///////////////////////// THREATS ////////////////////////\n\n    let threat_def_ids = threat_definitions.map(d => d.id);\n\n    //The remaining concepts are threats\n    concepts = nodes.filter(d =>\n      d.type === 'element' || threat_ids.indexOf(d.id) >= 0 ? false : true\n    );\n    concepts.forEach(d => {\n      //Get this node's threat category\n      let threats_connected = linked_to_id[d.id].filter(\n        n => n.group === 'threat category'\n      );\n      if (threats_connected.length !== 1)\n        console.log('not 1 threat category', d.id, d.label, threats_connected);\n      d.threat_category = threats_connected[0].id;\n\n      d.opacity = 1;\n      d.fill = color_threat_scale(d.threat_category);\n      concept_by_id[d.id] = d;\n\n      let def = threat_def_ids.indexOf(d.id);\n      d.definition =\n        def >= 0\n          ? threat_definitions[def].definition\n          : 'definition to be added';\n    }); //forEach\n\n    //Sort by the threat category and then alphabetically\n    concepts = concepts.sort((a, b) => {\n      if (\n        threat_ids.indexOf(a.threat_category) <\n        threat_ids.indexOf(b.threat_category)\n      )\n        return -1;\n      if (\n        threat_ids.indexOf(a.threat_category) >\n        threat_ids.indexOf(b.threat_category)\n      )\n        return 1;\n      if (a.label < b.label) return -1;\n      if (a.label > b.label) return 1;\n      return 0;\n    }); //sort\n\n    makeConcepts(concepts);\n    let concepts_other = concepts.filter(\n      d => d.threat_category !== 'vocabulary_ich_1286'\n    );\n    //Those threats connected to \"Weakened practice and transmission (categ)\"\n    let concepts_weak = concepts.filter(\n      d => d.threat_category === 'vocabulary_ich_1286'\n    );\n\n    /////////////////////// ICH ELEMENTS /////////////////////\n\n    elements = nodes.filter(d => d.type === 'element');\n\n    elements.forEach(d => {\n      //Get the threats an element is mapped to (all of weight 2)\n      let threats_connected = linked_to_id[d.id].filter(\n        n => n.group === 'threat'\n      );\n      d.threats = threats_connected.map(n => n.id);\n      d.threats = d.threats.sort((a, b) => {\n        let a_threat = threat_ids.indexOf(concept_by_id[a].threat_category);\n        let b_threat = threat_ids.indexOf(concept_by_id[b].threat_category);\n        if (a_threat < b_threat) return -1;\n        if (a_threat > b_threat) return 1;\n        return 0;\n      }); //sort\n      d.threat_categories = [\n        ...new Set(d.threats.map(l => concept_by_id[l].threat_category)),\n      ];\n    }); //forEach\n    ICH_num_all = elements.length;\n\n    //Sort alphabetically\n    elements = elements.sort((a, b) => {\n      if (a.label < b.label) return -1;\n      if (a.label > b.label) return 1;\n      return 0;\n    });\n  } //function dataPreparation\n\n  ////////////////// Calculate node placement //////////////////\n  function nodePlacement() {\n    let num, start_angle, end_angle;\n    let offset = 0.025 * pi2;\n\n    ////////////////////// ICH ELEMENTS //////////////////////\n\n    num = elements.length;\n    start_angle = pi1_2 + offset;\n    end_angle = pi2 - (pi1_2 + offset);\n    elements.forEach((d, i) => {\n      d.angle = (i / (num - 1)) * (end_angle - start_angle) + start_angle;\n      let sign = i % 2 === 0 ? -1 : 1;\n      let rad = radius_elements + sign * radius_elements_offset;\n      d.x = rad * Math.cos(d.angle - pi1_2);\n      d.y = rad * Math.sin(d.angle - pi1_2);\n    }); //forEach\n\n    //////////////////// THREAT CATEGORIES ///////////////////\n    // d.title\n\n    num = threats.length;\n    let total_width = 2 * radius_threats;\n    let space = total_width / num;\n    threats.forEach((d, i) => {\n      d.x = (i + 0.5) * space - radius_threats;\n      d.y = 0;\n      d.space = space;\n\n      d.fill = color_threat_scale(d.id);\n      d.opacity = 1;\n\n      //Get the total number of lines\n      ctx_nodes.font = 'normal normal 400 24px ' + font_family;\n      d.num_lines = wrapText(\n        ctx_nodes,\n        d.title,\n        0,\n        0,\n        space,\n        threat_line_height,\n        false,\n        true\n      );\n\n      //Get the locations of the circles\n      let circle_offset = 10;\n      let offset = d.num_lines * threat_line_height;\n      d.circle_offset = offset / 2 + circle_offset;\n    }); //forEach\n\n    ////////////////////// CONCEPT ARCS //////////////////////\n\n    // d.threat_category, label, definition\n\n    //Roll up the countries into an array of areas and the number of countries per area\n    threats_nest = d3\n      .nest()\n      .key(d => d.threat_category)\n      .entries(concepts);\n\n    // offset = 0\n    start_angle = -pi1_2 + offset;\n    end_angle = pi1_2 - offset;\n    let padding = 0.04;\n    pie_concept\n      .startAngle(start_angle)\n      .endAngle(end_angle)\n      .padAngle(padding);\n\n    ctx_nodes.font = 'normal normal 300 19px ' + font_family; //Needed to get the text width\n    concept_arcs = pie_concept(threats_nest);\n    concept_arcs.forEach(d => {\n      d.totalAngle = d.endAngle - d.startAngle;\n      d.centerAngle = d.startAngle + d.totalAngle / 2;\n      d.opacity = 1;\n\n      let num = d.data.values.length;\n      let angle_step = (d.totalAngle - 2 * padding) / num;\n      let angle = d.startAngle + 1.5 * padding;\n\n      //Loop over each concept within this threat category\n      d.data.values.forEach(n => {\n        n.angle = angle;\n        n.angle_width = angle_step;\n        n.x = radius_concept * Math.cos(angle - pi1_2);\n        n.y = radius_concept * Math.sin(angle - pi1_2);\n        n.r = concept_radius;\n        n.width = ctx_nodes.measureText(n.label).width;\n        angle = angle + angle_step;\n      }); //forEach\n    }); //forEach\n  } //function nodePlacement\n\n  ////////////////// Calculate edge placement //////////////////\n  function edgePlacement() {\n    ////////////////////// Concept edges /////////////////////\n\n    //Get all the edges that should run between the threat categories and the threats\n    let concept_ids = concepts.map(l => l.id);\n    edges_concepts = edges.filter(d => {\n      if (\n        threat_ids.indexOf(d.source) >= 0 &&\n        concept_ids.indexOf(d.target) >= 0\n      )\n        return true;\n      else if (\n        threat_ids.indexOf(d.target) >= 0 &&\n        concept_ids.indexOf(d.source) >= 0\n      )\n        return true;\n      else return false;\n    }); //filter\n\n    edges_concepts.forEach(d => {\n      edge_concept_by_id[d.source + ',' + d.target] = true;\n      d.source = concept_by_id[d.source]; //Threat\n      d.target = threat_by_id[d.target]; //Threat category\n      d.sign_pos = -1;\n      d.opacity = opacity_concept_default;\n    }); //forEach\n\n    ////////////////////// Element edges /////////////////////\n\n    elements.forEach(d => {\n      d.threat_categories.forEach(l => {\n        edges_elements.push({\n          source: d.id,\n          target: l,\n        }); //push\n      }); //forEach\n    }); //forEach\n\n    edges_elements.forEach(d => {\n      edge_concept_by_id[d.source + ',' + d.target] = true;\n      d.source = node_by_id[d.source]; //ICH element\n      d.target = threat_by_id[d.target]; //Threat category\n      d.sign_pos = 1;\n      d.opacity = opacity_element_default;\n\n      d.target.degree += 1;\n    }); //forEach\n\n    //Calculate the line points for the edges\n    line.context(ctx_edges);\n    edges_elements.forEach(d => {\n      let target_y = d.target.y + d.sign_pos * d.target.circle_offset;\n\n      let dx = d.target.x - d.source.x;\n      let dy = d.target.y - d.source.y;\n\n      let r_source = radius_elements; //Math.sqrt(sq(d.source.x) + sq(d.source.y))\n      let r_source_offset = Math.sqrt(sq(dx) + sq(dy));\n      let angle_offset = Math.atan2(dy, dx) - pi1_2 + pi2;\n\n      let cr1 = r_source + cr1_offset_scale(r_source_offset);\n      let cx1 = cr1 * Math.cos(d.source.angle - pi1_2);\n      let cy1 = cr1 * Math.sin(d.source.angle - pi1_2);\n\n      let angle2 =\n        pi + (angle_offset - pi) * 0.5 * angle2_offset_scale(r_source_offset);\n      let cr2 = cr2_offset_scale(r_source_offset);\n      let cx2 = d.target.x + cr2 * Math.cos(angle2 - pi1_2);\n      let cy2 = target_y + cr2 * Math.sin(angle2 - pi1_2);\n\n      d.line_data = [\n        [d.source.x, d.source.y],\n        [cx1, cy1],\n        [cx2, cy2],\n        [d.target.x, target_y],\n      ];\n    }); //forEach\n  } //function edgePlacement\n\n  //////////////////////////////////////////////////////////////\n  ///////////////////////////// Arcs ///////////////////////////\n  //////////////////////////////////////////////////////////////\n\n  ////////////////// Prepare the arc functions /////////////////\n  function prepareArcs() {\n    ///////////////////// Node pie charts ////////////////////\n    //Node pie charts\n    arc_nodes\n      .outerRadius(node_radius)\n      .innerRadius(0)\n      .context(ctx_nodes);\n\n    ///////////////////// Concept threats ////////////////////\n    arc_concept\n      .startAngle(d => d.angle - 0.5 * d.angle_width)\n      .endAngle(d => d.angle + 0.5 * d.angle_width)\n      .innerRadius(radius_concept - 2 * concept_radius)\n      .outerRadius(d => radius_concept + 2 * concept_radius + d.width + 10);\n  } //function prepareArcs\n\n  //////////////////////////////////////////////////////////////\n  //////////////////////////// Texts ///////////////////////////\n  //////////////////////////////////////////////////////////////\n\n  ////////////// ICH element label outside circle //////////////\n  function showElementTitle(ctx, type, text, ICH_num) {\n    text = text ? text : ICH_num + ' | ' + translations[language].titles[0];\n    //Create a white arc on the background so cover the potential fixed title\n    if (type === 'hover') {\n      ctx.fillStyle = 'white';\n      ctx.beginPath();\n      ctx.arc(\n        0,\n        0,\n        radius_elements + 2 * radius_elements_offset + 10,\n        pi * 0.05,\n        pi * 0.95\n      );\n      ctx.arc(0, 0, radius_elements_title + 40, pi * 0.95, pi * 0.05, true);\n      ctx.closePath();\n      ctx.fill();\n    } //if\n\n    //Draw a background arc\n    ctx.fillStyle = type === 'nodes' ? arc_gradient_nodes : arc_gradient_hover;\n    ctx.beginPath();\n    ctx.arc(0, 0, radius_elements_title, pi * 0.15, pi * 0.85);\n    ctx.arc(0, 20, radius_elements_title - 8, pi * 0.87, pi * 0.17, true);\n    ctx.fill(); //18 -8 0.82 0.22\n\n    //Draw the text\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = 'center';\n    ctx.font = 'normal normal 400 36px ' + font_family;\n    ctx.fillStyle = FILL_COLOR;\n    drawTextAlongArc(ctx, text, pi, radius_elements_title, 'down', 0.6, false);\n\n    // let font_size = fitText(ctx, text, 34, 2*radius_elements_title)\n    // ctx.font = \"normal normal 400 \" + font_size + \"px \" + font_family\n    // ctx.strokeText(text, 0, 50)\n    // ctx.fillText(text, 0, 50)\n\n    // ctx.font = \"normal normal 400 34px \" + font_family\n    // wrapText(ctx, text, 0, 250, 2*300, 48, false)\n  } //function showElementTitle\n\n  /////////////////// Concept label in circle //////////////////\n  function showConceptTitle(ctx, d) {\n    ctx.textBaseline = 'bottom';\n    ctx.textAlign = 'center';\n    ctx.fillStyle = d.fill;\n    ctx.strokeStyle = BACK_COLOR;\n    ctx.lineWidth = 8;\n\n    //Add the threat's name\n    // let font_size = fitText(ctx, d.label, 44, 2*radius_concept_title)\n    let offset = -350;\n    ctx.font = 'normal normal 400 ' + 43 + 'px ' + font_family;\n    ctx.strokeText(d.label, 0, offset);\n    ctx.fillText(d.label, 0, offset);\n\n    //Add small rectangle below\n    let width_text = ctx.measureText(d.label).width * 0.4;\n    ctx.strokeRect(0 - width_text / 2, offset, width_text, 5);\n    ctx.fillRect(0 - width_text / 2, offset, width_text, 5);\n\n    ctx.font = 'normal normal 400 20px IBM Plex Serif';\n    ctx.textBaseline = 'middle';\n    let line_height = 30;\n    let max_width = 2 * radius_threats * 0.6;\n    // let lines = wrapText(ctx, d.definition, 0, -270, max_width, line_height, false, true) + 0.5\n    // //Create background white rect that's a little see through\n    // ctx.fillStyle = \"rgba(255,255,255,0.6)\"\n    // ctx.fillRect(-max_width/2, -290, max_width, lines * line_height)\n    //Add threat definition below\n    ctx.fillStyle = FILL_COLOR;\n    wrapText(ctx, d.definition, 0, -270, max_width, line_height, true);\n  } //function showConceptTitle\n\n  ///////////////// Smallest fitting font size /////////////////\n  function fitText(ctx, text, font_size, width) {\n    //Lower the font size until the text fits the canvas\n    do {\n      font_size -= 1;\n      ctx.font = 'normal normal 400 ' + font_size + 'px ' + font_family;\n    } while (ctx.measureText(text).width > width);\n    return font_size;\n  } //function fitText\n\n  ////////////////// Fit & wrap text on canvas /////////////////\n  //From: https://codepen.io/bramus/pen/eZYqoO\n  function wrapText(\n    ctx,\n    text,\n    x,\n    y,\n    max_width,\n    line_height = threat_line_height,\n    do_stroke = false,\n    get_num_lines = false\n  ) {\n    let words = text.split(' ');\n    let line = '';\n    let num_lines = 0;\n\n    for (let n = 0; n < words.length; n++) {\n      let new_line = line + words[n] + ' ';\n      let new_width = ctx.measureText(new_line).width;\n      if (new_width > max_width && n > 0) {\n        if (!get_num_lines) {\n          if (do_stroke) ctx.strokeText(line.trim(), x, y);\n          ctx.fillText(line.trim(), x, y);\n        } //if\n        num_lines += 1;\n        line = words[n] + ' ';\n        y += line_height;\n      } else line = new_line;\n    } //for n\n    if (!get_num_lines) {\n      if (do_stroke) ctx.strokeText(line.trim(), x, y);\n      ctx.fillText(line.trim(), x, y);\n    } //if\n    num_lines += 1;\n\n    if (get_num_lines) return num_lines;\n  } //function wrapText\n\n  ////////////////////// Draw curved text //////////////////////\n  function drawTextAlongArc(ctx, str, angle, radius, side, kerning = 0.6) {\n    let startAngle = side === 'up' ? angle : angle - pi;\n    if (side === 'up')\n      str = str\n        .split('')\n        .reverse()\n        .join(''); // Reverse letters\n\n    //Rotate 50% of total angle for center alignment\n    for (let j = 0; j < str.length; j++) {\n      let charWid = ctx.measureText(str[j]).width;\n      startAngle +=\n        (charWid + (j === str.length - 1 ? 0 : kerning)) / radius / 2;\n    } //for j\n\n    //Draw thick white stroke as background\n    ctx.strokeStyle = BACK_COLOR;\n    ctx.lineWidth = 22;\n    ctx.lineCap = 'butt';\n    ctx.beginPath();\n    ctx.arc(\n      0,\n      0,\n      radius_elements_title + 4,\n      pi1_2 - startAngle - 0.01,\n      pi1_2 + startAngle + 0.01\n    );\n    ctx.stroke();\n\n    //Draw the text\n    ctx.beginPath();\n    ctx.save();\n    ctx.rotate(startAngle);\n    for (let n = 0; n < str.length; n++) {\n      let charWid = ctx.measureText(str[n]).width / 2; // half letter\n      //Rotate half letter\n      ctx.rotate(-charWid / radius);\n      // ctx.strokeText(str[n], 0, (side === \"up\" ? -1 : 1) * radius)\n      ctx.fillText(str[n], 0, (side === 'up' ? -1 : 1) * radius);\n      //Rotate another half letter\n      ctx.rotate(-(charWid + kerning) / radius);\n    } //for n\n    ctx.restore();\n  } //function drawTextAlongArc\n\n  //////////////////////////////////////////////////////////////\n  //////////////// Hidden hover element functions //////////////\n  //////////////////////////////////////////////////////////////\n\n  /////////////// Draw the hidden mouseover nodes //////////////\n  function drawHiddenElements() {\n    //Draw the invisible ICH element circles on the SVG\n    hover_ich = g_scale\n      .append('g')\n      .attr('class', 'element-hover-group')\n      .selectAll('.element-circle')\n      .data(elements)\n      .enter()\n      .append('circle')\n      .attr('class', 'element-circle')\n      .attr('cx', d => d.x)\n      .attr('cy', d => d.y)\n      .attr('r', node_radius)\n      .style('fill', 'none')\n      // .style(\"opacity\", \"0.4\")\n      .style('pointer-events', 'all')\n      .style('cursor', 'pointer');\n\n    //Draw the invisible rectangles of the threat categories\n    hover_category = g_scale\n      .append('g')\n      .attr('class', 'category-hover-group')\n      .selectAll('.category-rect')\n      .data(threats)\n      .enter()\n      .append('rect')\n      .attr('class', 'category-rect')\n      .attr('x', d => d.x - d.space / 2)\n      .attr('y', d => d.y - ((d.num_lines + 1) * threat_line_height) / 2)\n      .attr('width', d => d.space)\n      .attr('height', d => (d.num_lines + 1) * threat_line_height)\n      .style('fill', 'none')\n      // .style(\"opacity\", \"0.4\")\n      .style('pointer-events', 'all')\n      .style('cursor', 'pointer');\n\n    //Draw the invisible arcs over the outside threats\n    hover_concept = g_scale\n      .selectAll('.threat-hover-path')\n      .data(concepts)\n      .enter()\n      .append('path')\n      .attr('class', 'threat-hover-path')\n      .attr('d', arc_concept)\n      .style('fill', 'none')\n      // .style(\"opacity\", \"0.4\")\n      .style('pointer-events', 'all')\n      .style('cursor', 'pointer');\n  } //function drawHiddenElements\n\n  /////////////// Set the mouseover functionality //////////////\n  function setHiddenHovers() {\n    hover_ich.on('click', d => {\n      mouseClick(d, 'element');\n      showModal(d);\n    });\n\n    hover_category\n      .on('click', d => mouseClick(d, 'category'))\n      .on('mouseover', d => {\n        if (!click_active) mouseOverCategory(d);\n        else {\n          clearCanvas([ctx_hover]);\n          ctx_hover.textBaseline = 'middle';\n          ctx_hover.textAlign = 'center';\n          ctx_hover.font = 'normal normal 400 24px ' + font_family;\n          drawCategories(ctx_hover, d, 1);\n        }\n      })\n      .on('mouseout', d => {\n        if (!click_active) mouseOverReset();\n        else clearCanvas([ctx_hover]);\n      });\n\n    hover_concept\n      .on('click', d => mouseClick(d, 'concept'))\n      .on('mouseover', d => {\n        if (!click_active) mouseOverConcept(d);\n        else {\n          clearCanvas([ctx_hover]);\n          ctx_hover.textBaseline = 'middle';\n          ctx_hover.font = 'normal normal 300 19px ' + font_family;\n          drawConcepts(ctx_hover, d, 1);\n          showConceptTitle(ctx_hover, d);\n        } //else\n      })\n      .on('mouseout', d => {\n        if (!click_active) mouseOverReset();\n        else clearCanvas([ctx_hover]);\n      });\n  } //function setHiddenHovers\n\n  //////////////////////////////////////////////////////////////\n  //////////////////// Node drawing functions //////////////////\n  //////////////////////////////////////////////////////////////\n\n  /////////////////////// Draw the nodes ///////////////////////\n  function drawElements(ctx, d, opacity = 1) {\n    opacity = opacity ? opacity : d.opacity;\n\n    //Draw the circles as mini pie charts\n    let arcs = pie_nodes(d.threat_categories);\n    ctx.save();\n    ctx.translate(d.x, d.y);\n    ctx.rotate(d.angle);\n    //Draw each slice\n    arcs.forEach(a => {\n      ctx.beginPath();\n      ctx.moveTo(0, 0); //Needed to make sure Chrome keeps them as circles even at small sizes\n      arc_nodes.context(ctx)(a);\n      ctx.closePath();\n      const c = chroma(color_threat_scale(a.data));\n      c.alpha(opacity);\n      ctx.fillStyle = c.css();\n      ctx.fill();\n    }); //forEach\n\n    //Outside white stroke\n    ctx.strokeStyle = chroma('white')\n      .alpha(opacity)\n      .css();\n    ctx.lineWidth = 4;\n    ctx.beginPath();\n    ctx.arc(0, 0, node_radius + 1.2, 0, pi2);\n    ctx.closePath();\n    ctx.stroke();\n\n    ctx.restore();\n  } //function drawElements\n\n  ////////////////// Draw the concept circles //////////////////\n  function drawConcepts(ctx, d, opacity) {\n    //At what angle different from 0 to flip the text direction\n    let flip = 0; //-0.1 * pi\n    opacity = opacity ? opacity : d.opacity;\n\n    //Rotate and then move the canvas origin to the concept \"dot\" location\n    ctx.save();\n    ctx.rotate(d.angle > 0 + flip ? d.angle - pi1_2 : d.angle + pi1_2);\n    ctx.translate((d.angle > 0 + flip ? 1 : -1) * radius_concept, 0);\n\n    //Draw the large degree based concept circle\n    ctx.globalCompositeOperation = 'multiply';\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.arc(0, 0, scale_concept_radius(d.degree), 0, pi2);\n    ctx.closePath();\n    ctx.fillStyle = chroma(d.fill)\n      .alpha(Math.max(0.05, opacity / 5))\n      .css();\n    ctx.fill();\n    ctx.globalCompositeOperation = 'source-over';\n\n    //Draw the small concept circle\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.arc(0, 0, concept_radius, 0, pi2);\n    ctx.closePath();\n    ctx.fillStyle = chroma(d.fill)\n      .alpha(opacity)\n      .css();\n    ctx.fill();\n\n    //Draw the text\n    ctx.textAlign = d.angle > 0 + flip ? 'start' : 'end';\n    let color_text = chroma.mix('black', d.fill, 0.1);\n    ctx.font = \"24px Helvetia\";\n    ctx.fillStyle = chroma(d.fill)\n      .alpha(opacity)\n      .css();\n    ctx.translate((d.angle > 0 + flip ? 1 : -1) * (concept_radius + 25), 0);\n    ctx.fillText(d.label, 0, -2);\n    ctx.restore();\n  } //function drawConcepts\n\n  ///////////////// Draw the threat categories /////////////////\n  function drawCategories(ctx, d, opacity) {\n    opacity = opacity ? opacity : d.opacity;\n\n    //Background degree circle\n    ctx.globalCompositeOperation = 'multiply';\n    ctx.beginPath();\n    ctx.moveTo(d.x, d.y);\n    ctx.arc(d.x, d.y, scale_threat_radius(d.degree), 0, pi2);\n    ctx.closePath();\n    ctx.fillStyle = chroma(d.fill)\n      .alpha(opacity / 6)\n      .css();\n    ctx.fill();\n    ctx.globalCompositeOperation = 'source-over';\n\n    ctx.fillStyle = chroma(d.fill)\n      .alpha(opacity)\n      .css();\n    // //Small circles around the text\n    // ctx.beginPath()\n    // //Top circle\n    // ctx.moveTo(d.x, d.y - d.circle_offset)\n    // ctx.arc(d.x, d.y - d.circle_offset, threat_circle_radius, 0, pi2)\n    // //Bottom circle\n    // ctx.moveTo(d.x, d.y + d.circle_offset)\n    // ctx.arc(d.x, d.y + d.circle_offset, threat_circle_radius, 0, pi2)\n    // ctx.closePath()\n    // ctx.fill()\n\n    //Rectangles on top and bottom\n    let space = d.space * 0.4;\n    ctx.fillRect(d.x - space / 2, d.y - d.circle_offset - 2, space, 4);\n    ctx.fillRect(d.x - space / 2, d.y + d.circle_offset - 2, space, 4);\n\n    //Draw the text\n    // let color_text = chroma.mix('black', d.fill, 0.9)\n    ctx.fillStyle = chroma(d.fill)\n      .alpha(opacity)\n      .css();\n    //Draw the text over multiple lines\n    wrapText(\n      ctx,\n      d.title,\n      d.x,\n      d.y - ((d.num_lines - 1) * threat_line_height) / 2 - 2.5,\n      d.space\n    );\n  } //function drawCategories\n\n  ////////// Add ring around hovered/clicked category //////////\n  function showCategoryRing(ctx, d, opacity) {\n    ctx.globalCompositeOperation = 'multiply';\n    ctx.beginPath();\n    ctx.arc(\n      d.x,\n      d.y,\n      Math.max(d.space / 2, scale_threat_radius(d.degree)) + 14,\n      0,\n      pi2\n    );\n    ctx.closePath();\n    ctx.lineWidth = 4;\n    ctx.strokeStyle = chroma(d.fill)\n      .alpha(opacity)\n      .css();\n    ctx.stroke();\n    ctx.globalCompositeOperation = 'source-over';\n  } //function showCategoryRing\n\n  //////////////////////////////////////////////////////////////\n  //////////////////// Edge drawing functions //////////////////\n  //////////////////////////////////////////////////////////////\n\n  ///////////////// Draw the ICH element edges /////////////////\n  function drawEdgesElements() {\n    // ctx_edges.globalCompositeOperation = \"multiply\" - makes it all tooooo slow\n    edges_elements.forEach(d => {\n      let stroke = color_threat_scale(d.target.id);\n      ctx_edges.strokeStyle = chroma(stroke)\n        .alpha(d.opacity)\n        .css();\n      ctx_edges.beginPath();\n      line(d.line_data);\n      ctx_edges.stroke();\n    }); //forEach\n    // ctx_edges.globalCompositeOperation = \"source-over\"\n  } //function drawEdgesElements\n\n  /////////////////// Draw the concept edges ///////////////////\n  function drawEdgesConcepts() {\n    ctx_edges.globalCompositeOperation = 'multiply';\n    edges_concepts.forEach(d => {\n      let stroke = color_threat_scale(d.target.id);\n      ctx_edges.strokeStyle = chroma(stroke)\n        .alpha(d.opacity)\n        .css();\n      ctx_edges.beginPath();\n      ctx_edges.moveTo(d.source.x, d.source.y);\n      let target_y = d.target.y + d.sign_pos * d.target.circle_offset;\n      if (d.center)\n        drawCircleArc(\n          ctx_edges,\n          d.center,\n          d.r,\n          d.source,\n          d.target,\n          d.sign,\n          target_y\n        );\n      else ctx_edges.lineTo(d.target.x, target_y);\n      ctx_edges.stroke();\n    }); //forEach\n    ctx_edges.globalCompositeOperation = 'source-over';\n  } //function drawEdgesConcepts\n\n  ////////////////// Draw a curved edge line ///////////////////\n  function drawCircleArc(ctx, c, r, p1, p2, side, target_y) {\n    let ang1 = Math.atan2(p1.y - c.y, p1.x - c.x);\n    let ang2 = Math.atan2(target_y - c.y, p2.x - c.x);\n    ctx.arc(c.x, c.y, r, ang1, ang2, side);\n  } //function drawCircleArc\n\n  /////////// Calculate the center for each edge arc ///////////\n  function calculateEdgeCenters(edges_data) {\n    //Calculates the curve factor of the upper lines outside of the center group\n    const scale_curve = d3\n      .scaleLinear() //Slightly magical-numbers like....\n      .domain([0, 0.1 * radius_threats, radius_threats])\n      .range([50, 2, 1]);\n\n    //Calculates the curve factor of the upper lines of the center group\n    const scale_curve_center = d3\n      .scalePow() //Slightly magical-numbers like....\n      .exponent(0.3)\n      .domain([0, 0.45 * radius_threats])\n      .range([35, 2])\n      .clamp(true);\n\n    edges_data.forEach(d => {\n      let curve_factor;\n      let target_y = d.target.y + d.sign_pos * d.target.circle_offset;\n\n      //Find a good radius\n      if (d.target.x !== 0) curve_factor = scale_curve(Math.abs(d.target.x));\n      else curve_factor = scale_curve_center(Math.abs(d.target.x - d.source.x));\n      d.r =\n        Math.sqrt(sq(d.target.x - d.source.x) + sq(target_y - d.source.y)) *\n        curve_factor;\n\n      //Find center of the arc function\n      let centers = findCenters(d.r, d.source, d.target, target_y);\n      if (d.source.y < 0) d.sign = d.target.x < d.source.x ? 1 : 0;\n      //1 flows from center to right\n      else d.sign = d.target.x < d.source.x ? 0 : 1;\n      d.center = d.sign ? centers.c2 : centers.c1;\n    }); //forEach\n\n    //////////// Calculate center for curved edges ///////////\n    //https://stackoverflow.com/questions/26030023\n    //http://jsbin.com/jutidigepeta/3/edit?html,js,output\n    function findCenters(r, p1, p2, target_y) {\n      // pm is middle point of (p1, p2)\n      let pm = { x: 0.5 * (p1.x + p2.x), y: 0.5 * (p1.y + target_y) };\n      // compute leading vector of the perpendicular to p1 p2 == C1C2 line\n      let perpABdx = -(target_y - p1.y);\n      let perpABdy = p2.x - p1.x;\n      // normalize vector\n      let norm = Math.sqrt(sq(perpABdx) + sq(perpABdy));\n      perpABdx /= norm;\n      perpABdy /= norm;\n      // compute distance from pm to p1\n      let dpmp1 = Math.sqrt(sq(pm.x - p1.x) + sq(pm.y - p1.y));\n      // sin of the angle between { circle center,  middle , p1 }\n      let sin = dpmp1 / r;\n      // is such a circle possible ?\n      if (sin < -1 || sin > 1) return null; // no, return null\n      // yes, compute the two centers\n      let cos = Math.sqrt(1 - sq(sin)); // build cos out of sin\n      let d = r * cos;\n      let res1 = { x: pm.x + perpABdx * d, y: pm.y + perpABdy * d };\n      let res2 = { x: pm.x - perpABdx * d, y: pm.y - perpABdy * d };\n      return { c1: res1, c2: res2 };\n    } //function findCenters\n  } //function calculateEdgeCenters\n\n  //////////////////////////////////////////////////////////////\n  /////////////////// Canvas drawing functions /////////////////\n  //////////////////////////////////////////////////////////////\n\n  ////////////////////// Clear all canvases ////////////////////\n  function clearCanvas(ctxs) {\n    ctxs.forEach(d => {\n      d.clearRect(\n        (-margin.left - width / 2) / scale_factor,\n        (-margin.top - height / 2) / scale_factor,\n        total_width / scale_factor,\n        total_height / scale_factor\n      );\n    });\n  } //function clearCanvas\n\n  /////////////// Draw all parts on the canvases ///////////////\n  function drawCanvas() {\n    //Clear everything\n    clearCanvas([ctx_edges, ctx_nodes, ctx_hover]);\n\n    //Draw the edges between the categories and the threats\n    ctx_edges.lineWidth = 3;\n    drawEdgesConcepts();\n    //Draw the edges between the categories and the ICH elements\n    drawEdgesElements();\n\n    //Draw threat categories\n    ctx_nodes.textBaseline = 'middle';\n    ctx_nodes.textAlign = 'center';\n    ctx_nodes.font = 'normal normal 400 24px ' + font_family;\n    threats.forEach(d => {\n      drawCategories(ctx_nodes, d);\n    });\n\n    //Draw the other concepts around the top outside\n    ctx_nodes.textBaseline = 'middle';\n    ctx_nodes.font = 'normal normal 300 19px ' + font_family;\n    concepts.forEach(d => {\n      drawConcepts(ctx_nodes, d);\n    });\n\n    //Draw the ICH elements around the bottom outside\n    elements.forEach(d => {\n      drawElements(ctx_nodes, d);\n    });\n\n    //Show the title\n    if (mouse_hover_active) {\n      if (hover_type === 'element')\n        showElementTitle(ctx_nodes, 'nodes', current_hover.label);\n      else showElementTitle(ctx_nodes, 'nodes', null, ICH_num);\n      //Show threat concept title when hovered over top threat\n      if (hover_type === 'concept') showConceptTitle(ctx_nodes, current_hover);\n      if (hover_type === 'category')\n        showCategoryRing(ctx_nodes, current_hover, 1);\n    } else if (click_active) {\n      if (hover_type === 'element')\n        showElementTitle(ctx_nodes, current_click.label, 'nodes');\n      else if (hover_type === 'concept')\n        showConceptTitle(ctx_nodes, current_click);\n    } else {\n      showElementTitle(ctx_nodes, 'nodes', null, ICH_num_all);\n    } //else\n  } //function drawCanvas\n\n  //////////////////////////////////////////////////////////////\n  //////////////////// Mouse click functions ///////////////////\n  //////////////////////////////////////////////////////////////\n\n  function mouseClick(d, click_type) {\n    if (d3.event) d3.event.stopPropagation();\n    click_active = true;\n\n    //Call the correct drawing function\n    if (click_type === 'element') mouseOverElement(d);\n    else if (click_type === 'concept') mouseOverConcept(d);\n    else if (click_type === 'category') mouseOverCategory(d);\n\n    current_click = d;\n  } //function mouseClick\n\n  ////////////////////// Manually fix node /////////////////////\n  chart.fixNode = node_id => {\n    //Check if it's in the data\n    let node = node_by_id[node_id];\n    if (node) mouseClick(node, 'element');\n  }; //function fixNode\n\n  //////////////////////////////////////////////////////////////\n  //////////////////// Mouse over functions ////////////////////\n  //////////////////////////////////////////////////////////////\n\n  /////////////////// Mouse over ICH elements //////////////////\n  function findElement() {\n    let m = d3.mouse(this);\n    let x = (m[0] - total_width / 2) / scale_factor;\n    let y = (m[1] - total_height / 2) / scale_factor;\n    let r = Math.sqrt(x * x + y * y);\n\n    //Only continue of the mouse is somewhere near the ICH element arc\n    if (\n      y > 70 &&\n      r > radius_elements - 2 * radius_elements_offset &&\n      r < radius_elements + 2 * radius_elements_offset\n    ) {\n      //Search for nearby ICH element\n      let found = diagram.find(x, y, (node_radius * 2) / scale_factor);\n      //A match is found and it's a new one\n      if (found && current_hover !== found.data) {\n        if (!click_active) mouseOverElement(found.data);\n        //If a click is active and you hover over another element\n        else if (click_active) {\n          current_hover = found.data;\n          clearCanvas([ctx_hover]);\n          drawElements(ctx_hover, found.data, 1);\n          showElementTitle(ctx_hover, 'hover', found.data.label);\n        } //else if\n      } //if\n      //When hovering away from an element and no click is active\n      else if (!click_active && !found && mouse_hover_active) mouseOverReset();\n      //When a click is active and you hover away\n      else if (click_active && !found) {\n        clearCanvas([ctx_hover]);\n        current_hover = null;\n      } //else if\n    } //if\n    else if (\n      click_active &&\n      y > 70 &&\n      r > radius_elements - 2 * radius_elements_offset - 40\n    )\n      clearCanvas([ctx_hover]);\n    else if (!click_active && mouse_hover_active && hover_type === 'element')\n      mouseOverReset();\n  } //function findElement\n\n  function mouseOverElement(d) {\n    //If the canvas fade is still active, stop it\n    if (timer_draw) timer_draw.stop();\n    mouse_hover_active = true;\n    hover_type = 'element';\n    current_hover = d;\n    let id = d.id;\n\n    //Draw the edges from element to threat category\n    edges_elements.forEach(l => {\n      l.opacity = l.source.id === id ? 0.5 : 0;\n    });\n\n    //Draw the edges from the threat category to the threats\n    edges_concepts.forEach(l => {\n      l.opacity =\n        d.threats.indexOf(l.source.id) >= 0 &&\n        d.threat_categories.indexOf(l.target.id) >= 0\n          ? 0.5\n          : 0;\n    });\n\n    //Draw the ICH circles\n    elements.forEach(n => {\n      n.opacity = n.id === id ? 1 : 0.1;\n    });\n\n    //Draw connected threat categories\n    threats.forEach(n => {\n      n.opacity = d.threat_categories.indexOf(n.id) >= 0 ? 1 : 0.1;\n    });\n\n    //Draw connected threats\n    concepts.forEach(n => {\n      n.opacity = d.threats.indexOf(n.id) >= 0 ? 1 : 0.1;\n    });\n\n    //Draw it all\n    drawCanvas();\n  } //function mouseOverElement\n\n  ///////////////// Mouse over threat category /////////////////\n  function mouseOverCategory(d) {\n    if (timer_draw) timer_draw.stop();\n    mouse_hover_active = true;\n    hover_type = 'category';\n    current_hover = d;\n    let id = d.id;\n\n    //Draw the edges from threat category to the elements\n    edges_elements.forEach(l => {\n      l.opacity = l.target.id === id ? 0.5 : 0;\n    });\n\n    //Draw the edges from the threat category to the threats\n    edges_concepts.forEach(l => {\n      l.opacity = l.target.id === id ? 0.5 : 0;\n    });\n\n    //Draw the ICH circles\n    elements.forEach(n => {\n      n.opacity = n.threat_categories.indexOf(id) >= 0 ? 1 : 0.1;\n    });\n    ICH_num = elements.filter(n => n.threat_categories.indexOf(id) >= 0).length;\n\n    //Draw connected threat categories\n    threats.forEach(n => {\n      n.opacity = n.id === id ? 1 : 0.1;\n    });\n\n    //Draw connected threats\n    concepts.forEach(n => {\n      n.opacity = n.threat_category === id ? 1 : 0.1;\n    });\n\n    //Draw it all\n    drawCanvas();\n  } //function mouseOverElement\n\n  ///////////////////// Mouse over threats /////////////////////\n  function mouseOverConcept(d) {\n    //If the canvas fade is still active, stop it\n    if (timer_draw) timer_draw.stop();\n    mouse_hover_active = true;\n    hover_type = 'concept';\n    current_hover = d;\n    let id = d.id;\n\n    //Draw the edges from the threat to the threat category\n    edges_concepts.forEach(l => {\n      l.opacity = l.source.id === id ? 0.5 : 0;\n    });\n\n    //Draw the edges from connected elements to threat category\n    edges_elements.forEach(l => {\n      l.opacity =\n        l.source.threats.indexOf(id) >= 0 && l.target.id === d.threat_category\n          ? 0.5\n          : 0;\n    });\n\n    //Draw the connected ICH circles\n    elements.forEach(n => {\n      n.opacity = n.threats.indexOf(id) >= 0 ? 1 : 0.1;\n    });\n    ICH_num = elements.filter(n => n.threats.indexOf(id) >= 0).length;\n\n    //Draw connected threat categories\n    threats.forEach(n => {\n      n.opacity = n.id === d.threat_category ? 1 : 0.1;\n    });\n\n    //Draw threats\n    concepts.forEach(n => {\n      n.opacity = n.id === id ? 1 : 0.1;\n    });\n\n    //Draw it all\n    drawCanvas();\n  } //function mouseOverConcept\n\n  //////////////////////////////////////////////////////////////\n  ///////////////////// Mouse out functions ////////////////////\n  //////////////////////////////////////////////////////////////\n\n  function mouseOverReset() {\n    if (timer_draw) timer_draw.stop();\n    mouse_hover_active = false;\n    hover_type = null;\n    current_hover = null;\n\n    //Animate the opacities coming back\n    fadeCanvasBackIn();\n  } //function mouseOverReset\n\n  /////////////////// Fade everything back in //////////////////\n  function fadeCanvasBackIn() {\n    //Transition settings\n    const duration = 250;\n    const ease = d3.easeQuadInOut;\n\n    //Calculate the opacity interpolator\n    nodes.forEach(n => {\n      n.interpolate_opacity = d3.interpolate(n.opacity, 1);\n    });\n    edges_concepts.forEach(l => {\n      l.interpolate_opacity = d3.interpolate(\n        l.opacity,\n        opacity_concept_default\n      );\n    });\n    edges_elements.forEach(l => {\n      l.interpolate_opacity = d3.interpolate(\n        l.opacity,\n        opacity_element_default\n      );\n    });\n\n    //Fade everything back in\n    timer_draw = d3.timer(elapsed => {\n      //How far along the total duration are we (taking the easing into account)\n      let t = ease(Math.min(1, elapsed / duration));\n\n      //Set new opacities\n      nodes.forEach(n => {\n        n.opacity = n.interpolate_opacity(t);\n      });\n      edges_concepts.forEach(l => {\n        l.opacity = l.interpolate_opacity(t);\n      });\n      edges_elements.forEach(l => {\n        l.opacity = l.interpolate_opacity(t);\n      });\n\n      //Draw the canvas\n      drawCanvas();\n\n      //Stop when the duration has been reached\n      if (elapsed >= duration) timer_draw.stop();\n    }); //timer\n  } //function fadeCanvasBackIn\n\n  //////////////////////////////////////////////////////////////\n  ///////////////////// Save result to PNG /////////////////////\n  //////////////////////////////////////////////////////////////\n\n  chart.saveImage = (width_print = 20, units = 'cm') => {\n    ///////////// Calculate new sizes /////////////\n    //https://www.pixelcalculator.com/index.php?lang=en&dpi1=300&FS=2\n    const dpi_scale = 300 / 2.54; //300 dpi / 2.54cm\n    //Calculate the new scale factor\n    let sf_new;\n    if (units === 'px') sf_new = width_print / width;\n    else sf_new = (width_print * dpi_scale) / width;\n    let sf_scale = sf_new / sf;\n    //Check sizes\n    if (sf_new * width * sf_new * height > 268435456)\n      Error('requested canvas is probably too big for the browser to handle');\n    sf = sf_new;\n    sf_set = true;\n\n    ///////////// Resize everything /////////////\n    //Resize the actual canvas to this\n    let resizeDone = new Promise(function(resolve, reject) {\n      let result = chart.resize();\n      if (result === 1) resolve('resizing done');\n      else reject(Error('Resizing broke'));\n    });\n    //Do the next step after the resizing is done\n    resizeDone.then(\n      result => {\n        createPrintCanvas();\n        //Resize back\n        sf = sf_original;\n        sf_set = sf_set_original;\n        chart.resize();\n      },\n      error => {\n        console.log(error);\n      }\n    );\n\n    function createPrintCanvas() {\n      //Create \"off-screen\" canvas to combine the different layers\n      let canvas_save = document.createElement('canvas');\n      canvas_save.id = 'canvas-print';\n      let ctx_save = canvas_save.getContext('2d');\n      canvas_save.width = total_width * sf;\n      canvas_save.height = total_height * sf;\n\n      //Draw all the layers onto 1 canvas\n      ctx_save.drawImage(\n        canvas_edges.node(),\n        0,\n        0,\n        canvas_save.width,\n        canvas_save.height\n      );\n      ctx_save.drawImage(\n        canvas_nodes.node(),\n        0,\n        0,\n        canvas_save.width,\n        canvas_save.height\n      );\n      ctx_save.drawImage(\n        canvas_hover.node(),\n        0,\n        0,\n        canvas_save.width,\n        canvas_save.height\n      );\n\n      //Get the image\n      // a.href = canvas_save.toDataURL(\"image/png\") //won' work, too large a URL\n      try {\n        //Automatically download the canvas\n        //https://stackoverflow.com/questions/35480112\n        //Doesn't work in IE & Edge\n        canvas_save.toBlob(blob => {\n          let a = document.createElement('a');\n          let url = URL.createObjectURL(blob);\n          a.href = url;\n          a.download = 'ICH_Threats.png';\n          document.body.appendChild(a);\n          a.click();\n          document.body.removeChild(a);\n          URL.revokeObjectURL(url);\n        }, 'image/png');\n      } catch (err) {\n        //Manually download the canvas\n        document.body.appendChild(canvas_save);\n        document.body.style.overflow = 'auto';\n        window.scrollTo(0, document.body.scrollHeight);\n        console.log(\n          'Unable to automatically download the file due to photo and wrong URL'\n        );\n      } //try-catch\n    } //function createPrintCanvas\n  }; //function saveImage\n\n  //////////////////////////////////////////////////////////////\n  /////////////////////// Helper functions /////////////////////\n  //////////////////////////////////////////////////////////////\n\n  function sq(x) {\n    return x * x;\n  }\n\n  function roundTo(n, digits) {\n    let multiplicator = Math.pow(10, digits);\n    n = parseFloat((n * multiplicator).toFixed(11));\n    return Math.round(n) / multiplicator;\n  } //function roundTo\n\n  ///////////////// Find the device pixel ratio ////////////////\n  function getPixelRatio(ctx) {\n    //From https://www.html5rocks.com/en/tutorials/canvas/hidpi/\n    let devicePixelRatio = window.devicePixelRatio || 1;\n    let backingStoreRatio =\n      ctx.webkitBackingStorePixelRatio ||\n      ctx.mozBackingStorePixelRatio ||\n      ctx.msBackingStorePixelRatio ||\n      ctx.oBackingStorePixelRatio ||\n      ctx.backingStorePixelRatio ||\n      1;\n    let ratio = devicePixelRatio / backingStoreRatio;\n    return ratio;\n  } //function getPixelRatio\n\n  ////////////////// Retina non-blurry canvas //////////////////\n  function crispyCanvas(canvas, ctx) {\n    canvas\n      .attr('width', Math.round(sf * total_width))\n      .attr('height', Math.round(sf * total_height))\n      .style('width', `${total_width}px`)\n      .style('height', `${total_height}px`);\n    ctx.scale(sf * scale_factor, sf * scale_factor);\n    ctx.translate(\n      (margin.left + width / 2) / scale_factor,\n      (margin.top + height / 2) / scale_factor\n    );\n  } //function crispyCanvas\n\n  //////////////////////////////////////////////////////////////\n  //////////////////// Accessor functions //////////////////////\n  //////////////////////////////////////////////////////////////\n\n  chart.width = function(value) {\n    if (!arguments.length) return width;\n    width = value;\n    return chart;\n  };\n\n  chart.height = function(value) {\n    if (!arguments.length) return height;\n    height = value;\n    return chart;\n  };\n\n  chart.nodeRadius = function(value) {\n    if (!arguments.length) return node_radius;\n    node_radius = value;\n    return chart;\n  }; //function nodeRadius\n\n  chart.scaleFactor = function(value) {\n    if (!arguments.length) return sf;\n    sf = value;\n    sf_original = sf;\n    sf_set = true;\n    sf_set_original = true;\n    return chart;\n  }; //function scaleFactor\n\n  chart.zoomFactor = function(value) {\n    if (!arguments.length) return scale_multiplier;\n    scale_multiplier = value;\n    return chart;\n  }; //function zoomFactor\n\n  chart.showModal = function(_) {\n    return arguments.length ? ((showModal = _), chart) : showModal;\n  }; //function showModal\n\n  return chart;\n} //function createThreatVisual\n\nexport default createThreatVisual;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AACA;AAEA;AACA;AAIA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AADA;AAEA;AAAA;AACA;AAAA;AAHA;AAQA;AACA;AAAA;AACA;AAKA;AACA;AAKA;AACA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAKA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AAQA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAIA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAGA;AAAA;AAHA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AAAA;AACA;AAKA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAIA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAWA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AASA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AAEA;AACA;AACA;AADA;AAAA;AACA;AACA;AAMA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AAQA;AAAA;AACA;AAAA;AATA;AACA;AAgBA;AAQA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAXA;AACA;AAiBA;AAAA;AAWA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AADA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAGA;AAOA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AAOA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAWA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AAKA;AAAA;AAOA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAWA;AAGA;AACA;AACA;AACA;AAAA;AAzBA;AAkCA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAOA;AASA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAKA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;;;;A","sourceRoot":""}